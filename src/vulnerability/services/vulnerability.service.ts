import { Injectable, Logger } from '@nestjs/common';
import { AuthService } from 'src/auth/services/auth.service';
import { ScanService } from 'src/scan/services/scan.service';
import { VulnerabilityMap } from '../interface/vulnerability.interface';
import { Vulnerability } from 'src/scan/interface/vulnerability.interface';

@Injectable()
export class VulnerabilityService {
  private readonly logger = new Logger(VulnerabilityService.name);

  constructor(
    private readonly authService: AuthService,
    private readonly scanService: ScanService,
  ) {}

  async fullScan(): Promise<[VulnerabilityMap]> {
    try {
      const { token } = await this.authService.generateToken(
        process.env.cytix_username,
        process.env.cytix_password,
      );

      const bearer = `Bearer ${token}`;

      const { id } = await this.scanService.scan(bearer);
      const scanStartTime = new Date().toISOString();
      this.logger.log({
        message: `Scan started with ID: ${id}`,
        timestamp: scanStartTime,
      });

      const scanResults = await this.waitForScanCompletion(id, bearer);
      const parsedResults = this.parseAndFilterScanResults(scanResults);

      return parsedResults;
    } catch (error) {
      const errorTime = new Date().toISOString();
      this.logger.error({
        message: `Error during full scan: ${error.message}`,
        timestamp: errorTime,
      });
      throw error;
    }
  }

  private async waitForScanCompletion(
    id: string,
    bearer: string,
  ): Promise<any> {
    let scanResults = await this.scanService.getScanById(id, bearer);

    while (scanResults === 'Scan still running...') {
      const scanRunningTime = new Date().toISOString();
      this.logger.log({
        message: 'Scan still running...',
        timestamp: scanRunningTime,
      });
      await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait for 5 seconds before making the next request
      scanResults = await this.scanService.getScanById(id, bearer);
    }

    this.logger.log({
      message: 'Scan complete!',
      timestamp: new Date().toISOString(),
    });

    return scanResults;
  }

  private parseAndFilterScanResults(scanResults: any): any {
    const vulnerabilities = scanResults.vulnerabilities;

    const highRiskVulnerabilities = vulnerabilities.filter(
      (vulnerability: Vulnerability) => vulnerability.severity === 'High',
    );

    const transposedResults: VulnerabilityMap[] = highRiskVulnerabilities.map(
      (vulnerability: Vulnerability) => ({
        title: vulnerability.title,
        description: vulnerability.description,
        url: vulnerability.url,
      }),
    );

    return transposedResults;
  }
}
